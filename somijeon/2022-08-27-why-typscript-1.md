---
layout: post
title:  "왜 타입스크립트인가"
---

# 💡 자바스크립트 — 동적 타입 언어의 딜레마


## 1. 동적 타이핑이란?

C나 자바 같은 정적 타입(static/strong type) 언어는 변수를 선언할 때 데이터 타입을 사전에 선언한다. 한번 선언된 타입은 변경할 수 없으며 이 타입에 해당하는 값만 할당할 수 있다. 정적 타입 언어는 컴파일 시점에 타입 체크를 수행한다. 이를 통과하지 못하면 에러를 발생시키고 프로그램의 실행 자체를 막으므로 런타임에 발생하는 에러를 줄일 수 있다. 대표적인 정적 타입 언어로는 C, C++, 자바, 코틀린, 고 등이 있다.

```c
// C
char c; // c 변수에는 1바이트 정수 타입의 값만 할당 가능

int num; // num 변수에는 4바이트 정수 타입의 값만 할당 가능
```


그러나 자바스크립트의 변수는 선언이 아닌 할당에 의해 타입이 결정(타입 추론)된다. 그리고 재할당에 의해 변수의 타입은 언제든지 동적으로 변한다. 그야말로 귀에 걸면 귀걸이, 코에 걸면 코걸이가 되는 이런 특징을 동적 타이핑이라고 하고 이런 언어를 동적 타입 언어라 한다. 대표적인 동적 타입 언어로는 자바스크립트와 파이썬, PHP, 루비 등이 있다.
```js
// JavaScript
var foo;
console.log(typeof foo); // undefined

foo = 3;
console.log(typeof foo); // number

food = 'hi';
console.log(typeof foo); // string

foo = null;
console.log(typeof foo); // object

foo = {};
console.log(typeof foo); // object

foo = function() {};
console.log(typeof foo); // function

```
변수는 타입을 가질까? 그렇지 않다. 변수가 아니라 할당되는 값이 타입을 갖는 것이고 자바스크립트는 코드 블록에서 보는 것처럼 재할당에 의해 변수의 타입이 동적으로 결정되는 것이다.

## 2. 자바스크립트, 너는 Fox...⭐

자바스크립트의 변수는 콘솔로 값을 확인하기 전에는 타입을 확신할 수가 없다. 심지어 개발자의 의도와는 상관없이 자바스크립트 엔진에 의해 암묵적으로 타입이 자동 변환되기도 한다. 왜 이렇게 Syntax Error가 나지? 하고 들여다보면 생각도 못한 타입이 나오고는 했다. 에러 환각 파티에서 영원히 깨어날 수 없다는 두려움 때문에 큰 프로젝트는 정적 타입 언어인 타입스크립트를 선호한다. 동적 타입 언어는 그야말로 유연하고 매력적이지만, 신뢰성이 떨어지는 Fox인 것이다.

자바스크립트도 노력하면 약간 더 안정적인 코드를 짤 수도 있다. 변수를 사용할 때 다음과 같은 점을 매우 신경쓰면 된다.

### 1. 변수는 꼭 필요한 경우에 한해 제한적으로 사용한다.
  - 변수는 재할당에 의해 언제든지 변경될 수 있기 때문에 변수의 개수가 많으면 많을 수록 예측 못하는 오류가 발생활 확률도 높아진다.


### 2. 변수의 유효 범위(스코프)는 최대한 좁게 만든다.
  - 모든 식별자(변수 이름, 함수 이름, 클래스 이름 등)는 자신이 **선언된** 위치에 의해 다른 코드가 식별자 자신을 참조할 수 있는 유효 범위가 결정되는데 이를 스코프라 한다. 코드의 가장 바깥 영역에 선언된 변수는 전역 변수라고 하고 함수 내부에서 선언되면 함수 몸체 내부에서만 참조되는 함수 변수인 것이다.
  - 상위 스코프에서 유효한 변수는 하위 스코프에서 자유롭게 참조할 수 있지만 하위 스코프에서 유효한 변수를 상위 스코프에서 참조할 수는 없다. 부모님(상위 스코프)이 주신 카드나 용돈(변수)을 자식(하위 스코프)이 자유롭게 사용하는 것과 같다. 근데 이 상속은 낙장불입이다. 다시 자식 것을 가져올(참조할) 수가 없다.
  - 아래 예시를 보자. add 함수의 바깥, 즉 전역 스코프에서 x와 y는 정의된 적이 없으므로 제일 마지막 줄처럼 레퍼런스 에러가 난다. 그러나 함수의 몸체에서는 상위 스코프인 전역 스코프에서 참조해 올 수 있기 때문에 x와 y가 콘솔에 찍히는 것이다. 
  ```js
  function add(x, y) {
    // 지역(함수) 스코프, 자식 스코프라 상위 스코프인 전역에서 참조해 올 수 있다.
    console.log(x, y); // 2  5
    return x + y;
  }
  // 전역 스코프는 함수의 몸체 내부에서 참조할 수 없다.
  add(2, 5) 
  console.log(x, y) // ReferenceError:x is not defined
  ```
  - 자바스크립트의 스코프는 `var`로 선언했느냐 `let`/`const`로 선언했느냐에 따라 다르게 동작하므로 주의한다. `var` 키워드로 선언된 변수는 오로지 함수의 몸체만을 지역 스코프로 인정해서 **함수 레벨 스코프**라 한다. C나 자바 등을 비롯한 대부분의 프로그래밍 언어는 함수 몸체만이 아니라 모든 코드 블록(if, for, while, try/catch 등)이 지역스코프를 만들고 이를 **블록 레벨 스코프**라 한다.  `const`와 `let`은 블록 레벨 스코프를 가진다.

### 3. 전역 변수는 최대한 사용하지 않는다.
- 변수는 자신이 선언된 위치에서 생성되고 소멸한다. 예를 들어 함수 내부에서 선언된 지역 변수는 함수가 호출되면 생성되고 함수가 종료하면 소멸한다. 그런데 전역 변수는 전역 객체의 프로퍼티가 되고 브라우저 환경에서 전역 객체는 window이므로 `var`로 선언한 변수는 웹페이지를 닫을 때까지 유효하게 된다. 이렇게 생명 주기가 길면 메모리 리소스도 오랜 기간 소비하고 전역 변수의 상태가 변경될 수 있는 시간도 길고 기회도 많아진다. 가뜩이나 전역 변수는 어디서든 참조하고 할당할 수 있기 때문에 이 범위가 크면 클수록 상태가 변경되고 예측 못할 오류가 발생할 확률이 높아지는 것이다.
- 전역 변수의 사용을 억제하려면 모든 코드를 즉시 실행 함수로 감싸면 된다. 그러면 변수는 함수의 지역 변수가 된다.
```js
(function () {
  var foo = 10; // 즉시 실행 함수의 지역 변수
  // ...
}());

console.log(foo); // ReferenceError:foo is not defined
```
- 클래스를 모방해서 관련이 있는 변수와 함수를 모아 즉시 실행 함수로 감싸 하나의 모듈을 만드는 모듈 패턴을 쓸 수도 있다.
```js
var Counter = (function () { // 객체를 반환하는 즉시 실행 함수
  var num = 0; // private 변수

  return {
    increase() {
      return ++num;
    },
    decrease() {
      return --num;
    }
  }
}());

console.log(Counter.num); // undefined, private 변수는 외부로 노출 안 됨
console.log(Counter.increase()); // 1
console.log(Counter.increase()); // 2
console.log(Counter.decrease()); // 1

```


### 4. var 보다는 const를 사용한다.
- ES6를 사용한다면 `var` 키워드는 사용하지 않는다.
- 재할당이 필요한 경우에 한정해 `let` 키워드를 사용하고 변수의 스코프는 최대한 좁게 만든다.
- 변경이 발생하지 않고 재할당이 필요없는 **원시 값**과 **객체**에는 `const` 키워드를 사용한다.


### 5. 목적이나 의미를 파악할 수 있게 변수 네이밍에 각별히 신경쓴다.



> 다음 이야기
자바스크립트의 신뢰성을 높여줄 수 있는 타입스크립트의 특징과 그 사용법